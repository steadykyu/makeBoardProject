로그인 기능은 Json Web Token을 이영한 토큰 인증 방식을 택합니다.

이를 위해 토큰 발급과 사용자 인증을 위한 별도의 서버를 구축하지는 않고, 하나의 애플리케이션 내에서 사용자인증과 토큰 발급을 모두 수행하도록 설정합니다.

프로젝트 패키지 구조는 계층형(controller, service, repository)으로 유지하도록 합니다.

로그인 기능 구현에 앞서, 사용자에 관한 요구사항은 다음과 같습니다.
+ 이메일, 비밀번호, 사용자 이름, 닉네임을 입력받아서 사용자 정보를 생성한다.
+ 이메일과 닉네임의 중복은 허용되지 않는다.
+ 사용자는 여러개의 권한 등급을 가질 수 있다.
+ 비밀번호는 날 것 그대로 저장하지 않는다.
+ 닉네임을 변경 할 수 있다.

위의 요구사항을 염두해두고, 엔티티를 설계해보겠습니다.

# Member Entitiy
```java
package steadykyu.kyumarket.entity.member;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.util.List;
import java.util.Set;

import static java.util.stream.Collectors.toSet;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED) // 3
public class Member extends EntityDate { // 5

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "member_id")
    private Long id;

    @Column(nullable = false, length = 30, unique = true) // 1
    private String email;

    private String password; // 2

    @Column(nullable = false, length = 20)
    private String username;

    @Column(nullable = false, unique = true, length = 20) // 1
    private String nickname;

    @OneToMany(mappedBy = "member", cascade = CascadeType.ALL, orphanRemoval = true) // 4
    private Set<MemberRole> roles;

    public Member(String email, String password, String username, String nickname, List<Role> roles) {
        this.email = email;
        this.password = password;
        this.username = username;
        this.nickname = nickname;
        this.roles = roles.stream().map(r -> new MemberRole(this, r)).collect(toSet());
    }

    public void updateNickname(String nickname) { // 6
        this.nickname = nickname;
    }
}
```

## 코드 설명

> @NoArgsConstructor(access = AccessLevel.PROTECTED)

Lombok에서 제공하는 애노테이션으로, 파라미터가 없는 기본 생성자를 생성한다.
+ @RequiredArgsConstructor, @AllArgsConstructor 다른 애노테이션도 존재한다.

예시 : Student std = new Student();

access 는 생성자의 접근 제한자를 의미한다. 

## 요구사항에 맞는 필드 선언

1.  email과 nickname은 unique로 설정해주었습니다.   
    + 이로 인해 email과 nickname에는 인덱스가 형성되고, 중복을 허용하지 않는 제약조건이 추가되었습니다. 

2. password에는 NOT NULL 제약 조건이 걸려있지 않은데, 나중에 추가될 수 있는 소셜 로그인을 염두에 두고 그대로 두었습니다.
    + 소셜로그인(social login)이란? 
    + 소셜네트워크서비스(SNS)에서 제공하는 로그인 기능을 사용하여 다른 사이트에 로그인하는 것을 말한다.(카카오 계정 &rarr; 교육사이트 로그인 가능)

3. Member는 위와 같이 필드가 지정된 생성자를 사용하여 생성할 수 있습니다. 인스턴스가 불완전한 상태에 있음을 방지하기 위해, 기본 생성자는 외부로 노출할 필요가 없습니다. 하지만 JPA 명세에서는 엔티티에 기본 생성자를 요구하기 때문에, 기본 생성자는 접근 제어 레벨을 PROTECTED로 설정해두었습니다. 

4. 사용자를 나타내는 Member 엔티티와 권한 등급을 나타내는 Role 엔티티 간의 브릿지 테이블을 MemberRole 엔티티로 정의하였습니다. 한 명의 사용자는 여러 개의 권한을 가질 수 있고, 여러 개의 권한은 여러 사용자가 가지고 있을 수 있습니다. 이를 Member와 Role 간에 @ManyToMany로 설정하면 브릿지 테이블을 위한 엔티티를 별도로 선언하지 않아도 나타낼 수도 있습니다.

그러나 사용자가 가진 권한에 대해 어떤 추가적인 데이터(필드가)가 추가될지 모르기 때문에, 이에 대한 유연성을 위해 @OneToMany로 직접 선언하여 명시하였습니다.
+ 실제 실무에서도 @ManytoMany는 꺼려하는 편이라고 들었습니다.

MemberRole과 Member의 생명 주기를 맞추기 위해서 Member가 저장될 때 MemberRole 또한 연쇄적으로 저장되거나 제거될 수 있도록 cascade 옵션을 ALL로, orphanRemoval=true로 설정해줍니다.

실제로 각 사용자가 가질 수 있는 권한 등급은, 그렇게 많지는 않겠지만, 우리의 애플리케이션으로 조회 했을 때의 검색 성능 향상을 위해 Set으로 선언하였습니다.

5. EntityDate는 데이터가 생성된 시간, 수정된 시간을 자동으로 업데이트해주기 위해 사용하였습니다. 자세한 구조는 아래에서 살펴보도록 하겠습니다.

6. 닉네임을 업데이트할 수 있는 요구사항을 충족하기 위해, updateNickname 메소드를 작성해주었습니다.

# Role 엔티티

```java
package steadykyu.kyumarket.entity.member;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Role {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "role_id")
    private Long id;

    @Enumerated(EnumType.STRING) // 1
    @Column(nullable = false, unique = true) // 2
    private RoleType roleType;

    public Role(RoleType roleType) {
        this.roleType = roleType;
    }
}

```

Role 또한, MemberRole과 OneToMany 관계를 가지지만, Role에서 MemberRole을 조회할 필요는 없기 때문에 별도로 관계를 명시해주지 않았습니다.

1. RoleType은 어떤 권한 등급이 있는지 나타내는 Enum클래스입니다. EnumType.STRING으로 지정해줌으로써 데이터베이스에 저장할 때, 문자열로 저장하게 됩니다.

2. 권한 등급을 나타내는 RoleType은 실제로 몇개 되지는 않아서 굳이 인덱스를 생성할 필요는 없다고 생각됩니다. 하지만 중복된 이름의 RoleType이 생성되는 것을 방지하기 위해, unique 제약 조건을 걸어주었습니다.

# RoleType Enum
```java
package steadykyu.kyumarket.entity.member;

public enum RoleType {
    ROLE_NORMAL, ROLE_SPECIAL_SELLER, ROLE_SPECIAL_BUYER, ROLE_ADMIN
}
```
위와 같은 네 가지 권한만 지정해두도록 하겠습니다.

# MemberRole 엔티티
```java
package steadykyu.kyumarket.entity.member;

import lombok.*;

import javax.persistence.*;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@EqualsAndHashCode // 1
@IdClass(MemberRoleId.class) // 2
public class MemberRole {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "member_id")
    private Member member;

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "role_id")
    private Role role;

}
```
Member와 Role 엔티티 사이의 브릿지 테이블로 사용될 MemberRole 엔티티입니다.

> @EqualsAndHashCode

1. MemberRole은 Member에서 Set으로 저장되기 때문에, equals와 hashcode를 재정의해주었습니다.

> @NoArgsConstructor(access = AccessLevel.PROTECTED)

> @AllArgsConstructo

2. JPA 엔티티에 필요한 기본 생성자와 모든 필드를 생성자로 주입시켜주는 애노테이션을 사용했습니다.

> @IdClass

3. 여러 개의 필드를 조합하여 primary key로 사용하기 위해 @IdClass를 선언해주었습니다. 

MemberRoleId 클래스에 정의된 필드와 동일한 필드를, MemberRole에서 @Id로 선언해주면, composite key(복합 키)로 만들어낼 수 있습니다.

# MemberRoldeID 
복합키 생성을 위한 Embedded value

```java
package steadykyu.kyumarket.entity.member;

import lombok.*;

import javax.persistence.Embeddable;
import java.io.Serializable;

@Embeddable
@EqualsAndHashCode
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class MemberRoleId implements Serializable {

    private Member member;
    private Role role;

}
```

@IdClass로 사용될 클래스는 Serializable을 구현해주어야 합니다. 그리고 엔티티 내에서 composite key로 사용될 필드들을 동일하게 정의해주면 됩니다.

***
> Composite Key를 만들 때 주의할 점

composite key를 만들 때는, 기본적으로 알파벳 순으로 key가 만들어지게 됩니다. 이 때문에, 위 예시에서는 member, role의 순서로 key가 만들어집니다.

composite key에서는 key들의 순서가 중요합니다.
인덱스 구조가 첫번째 필드로 정렬된 뒤에, 그 다음으로 두번째 필드로 정렬되기 때문에,

만약 중복도가 높은 필드가 첫번째로 생성된다면, 필터링되는 레코드가 적어서 인덱스의 효과를 보지 못하게 됩니다.
***
우리가 진행하고 있는 프로젝트에서는, Role은 몇개밖에 생성되지 않기 때문에 중복도가 높고, Member는 계속해서 생성될 수 있기 때문에 중복도가 낮습니다.

따라서 role, member 순으로 인덱스가 생성된다면, member의 id로 레코드를 검색할 때 인덱스의 효과를 얻을 수 없습니다.

이러한 까닭에, composite key의 순서를 제어하려면, schema를 구성하는 스크립트를 직접 작성하거나 알파벳 순으로 필드의 이름을 변경하는 방법이 있겠습니다.

블로거분도 user로 이름을 설계했는데, composite key의 순서를 제어하기 위해 member로 이름을 변경하게 되었습니다.

# EntitiyDate